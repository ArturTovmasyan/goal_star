<?php

namespace LB\UserBundle\Entity\Repository;
use AppBundle\Controller\MetricController;
use Doctrine\DBAL\Connection;
use Doctrine\ORM\Query;
use Doctrine\ORM\Tools\Pagination\Paginator;
use LB\UserBundle\Entity\UserRelation;

/**
 * UserRelationRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class UserRelationRepository extends \Doctrine\ORM\EntityRepository
{

    public function findUsersCountByAction($user, $status)
    {
        $query =  $this->getEntityManager()
            ->createQueryBuilder()
            ->select('count(ur.id)')
            ->from("LBUserBundle:UserRelation", "ur")
            ->setParameter('currentUser', $user)
        ;

        switch ($status) {
            case UserRelation::LIKE:
                $query
                    ->where('(ur.toUser = :currentUser AND ur.fromStatus = :status AND ur.toStatus != :status) OR
                           (ur.fromUser = :currentUser AND ur.toStatus = :status AND ur.fromStatus != :status)')
                    ->setParameter('status', UserRelation::LIKE);
                break;
            case UserRelation::FRIEND:
                $query
                    ->where('(ur.toUser = :currentUser AND ur.fromStatus = :status AND ur.toStatus = :status) OR
                           (ur.fromUser = :currentUser AND ur.toStatus = :status AND ur.fromStatus = :status)')
                    ->setParameter('status', UserRelation::LIKE);
                break;
            case UserRelation::FAVORITE:
                $query
                    ->where('(ur.toUser = :currentUser AND ur.fromFavoriteStatus IN (:favoriteStatuses)) OR
                           (ur.fromUser = :currentUser AND ur.toFavoriteStatus IN (:favoriteStatuses))')
                    ->setParameter('favoriteStatuses', array(UserRelation::FAVORITE, UserRelation::NEW_FAVORITE));
                break;
            case UserRelation::VISITOR:
                $query
                    ->where('(ur.toUser = :currentUser AND ur.fromVisitorStatus IN (:visitStatuses)) OR
                           (ur.fromUser = :currentUser AND ur.toVisitorStatus IN (:visitStatuses))')
                    ->setParameter('visitStatuses', array(UserRelation::VISITOR, UserRelation::NEW_VISITOR));
                break;
            case UserRelation::LIKED_BY_ME:
                $query
                    ->where('(ur.toUser = :currentUser AND ur.fromStatus != :status AND ur.toStatus = :status) OR
                           (ur.fromUser = :currentUser AND ur.toStatus != :status AND ur.fromStatus = :status)')
                    ->setParameter('status', UserRelation::LIKE);
                break;
            case UserRelation::FAVORITE_BY_ME:
                $query
                    ->where('(ur.toUser = :currentUser AND ur.toFavoriteStatus IN (:favoriteStatuses)) OR
                           (ur.fromUser = :currentUser AND ur.fromFavoriteStatus IN (:favoriteStatuses))')
                    ->setParameter('favoriteStatuses', array(UserRelation::FAVORITE, UserRelation::NEW_FAVORITE));
                break;
        }
        $query
            ->andWhere("CASE WHEN ur.id is NOT NULL AND ur.fromUser = :currentUser AND ur.toStatus IS NOT NULL THEN ur.toStatus WHEN ur.id is NOT NULL AND ur.toUser = :currentUser AND ur.fromStatus IS NOT NULL THEN ur.fromStatus  ELSE -1 END != :block")
            ->setParameter('block', UserRelation::BLOCK);

        return $query->getQuery()->getSingleScalarResult();

    }

    /**
     * @param $userId
     * @return array
     */
    public function removeRelationByUser($userId)
    {
        return $this->getEntityManager()
            ->createQuery("DELETE
                           FROM LBUserBundle:UserRelation ur
                           WHERE ur.fromUser = :userId OR ur.toUser = :userId")
            ->setParameter('userId', $userId)
            ->execute();
    }

    /**
     * @param $user1Id
     * @param $user2Id
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findByUsers($user1Id, $user2Id)
    {
        return $this->getEntityManager()
            ->createQuery("SELECT ur, fu, tu
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           JOIN ur.toUser tu
                           WHERE (fu.id = :user1Id AND tu.id = :user2Id) OR (fu.id = :user2Id AND tu.id = :user1Id)")
            ->setParameter('user1Id', $user1Id)
            ->setParameter('user2Id', $user2Id)
            ->setMaxResults(1)
            ->getOneOrNullResult();
    }

    /**
     * @param $currentUser
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findLikesUsers($currentUser)
    {
        return $this->getEntityManager()
            ->createQuery("SELECT ur, fu, tu, tui, fui,
                            (CASE WHEN ur.fromUser = :currentUser then ur.isLikeReadTo ELSE ur.isLikeReadFrom END) as HIDDEN status,
                            (CASE WHEN ur.fromUser = :currentUser then ur.toStatusCreated ELSE ur.fromStatusCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           LEFT JOIN fu.profileImage fui
                           JOIN ur.toUser tu
                           LEFT JOIN tu.profileImage tui
                           WHERE (tu.id = :currentUser AND ur.fromStatus = :status AND ur.toStatus != :status) OR (fu.id = :currentUser AND ur.toStatus = :status AND ur.fromStatus != :status)
                           ORDER BY status ASC, created DESC
                           ")
            ->setHint(Query::HINT_FORCE_PARTIAL_LOAD, true)
            ->setParameter('currentUser', $currentUser->getId())
            ->setParameter('status', UserRelation::LIKE)
            ->getResult();
    }

    /**
     * @param $from
     * @param $to
     * @param $groupBy
     * @param $yearForMonthly
     * @return array
     */
    public function findForMetric($from, $to, $groupBy, $yearForMonthly)
    {
        $result = array();

        $likes =  $this->getEntityManager()
            ->createQueryBuilder()
            ->select('count(ur.id) as cnt,
                    (CASE WHEN ur.fromStatus = :like then date(ur.toStatusCreated)  ELSE date(ur.toStatusCreated) END) as created')
            ->from("LBUserBundle:UserRelation", "ur")
            ->where("(ur.fromStatus = :like and ur.toStatus != :like) OR (ur.toStatus = :like and ur.fromStatus != :like)")
            ->groupBy('created')
            ->setParameter('like', UserRelation::LIKE)
            ;

        if($from){
            $likes
                ->andWhere(':from <= (CASE WHEN ur.fromStatus = :like then date(ur.toStatusCreated) ELSE date(ur.toStatusCreated) END)')
                ->setParameter('from', $from);
        }
        if($to){
            $likes
                ->andWhere(':to >= (CASE WHEN ur.fromStatus = :like then date(ur.toStatusCreated) ELSE date(ur.toStatusCreated) END)')
                ->setParameter('to', $to);
        }

        if($yearForMonthly){
            $likes
                ->andWhere(':year = (CASE WHEN ur.fromStatus = :like then YEAR(ur.toStatusCreated) ELSE YEAR(ur.toStatusCreated) END)')
                ->setParameter('year', $yearForMonthly);
        }

        $likes = $likes->getQuery()->getResult();

        $this->myMergeArrays($likes, $result, 'Like', $groupBy);

        $favorites =  $this->getEntityManager()
            ->createQueryBuilder()
            ->select('count(ur.id) as cnt,
                          (CASE WHEN (ur.fromFavoriteStatus = :favorite OR  ur.fromFavoriteStatus = :newFavorite) then date(ur.fromFavoriteCreated) ELSE date(ur.toFavoriteCreated) END) as created')
            ->from("LBUserBundle:UserRelation", "ur")
            ->where("(ur.fromFavoriteStatus = :favorite OR  ur.fromFavoriteStatus = :newFavorite) OR
                               (ur.toFavoriteStatus = :favorite OR  ur.toFavoriteStatus = :newFavorite)")
            ->groupBy('created')
            ->setParameter('favorite', UserRelation::FAVORITE)
            ->setParameter('newFavorite', UserRelation::NEW_FAVORITE)
         ;

        if($from){
            $favorites
                ->andWhere(':from <= (CASE WHEN (ur.fromFavoriteStatus = :favorite OR  ur.fromFavoriteStatus = :newFavorite) then date(ur.fromFavoriteCreated) ELSE date(ur.toFavoriteCreated) END)')
                ->setParameter('from', $from);
        }
        if($to){
            $favorites
                ->andWhere(':to >= (CASE WHEN (ur.fromFavoriteStatus = :favorite OR  ur.fromFavoriteStatus = :newFavorite) then date(ur.fromFavoriteCreated) ELSE date(ur.toFavoriteCreated) END)')
                ->setParameter('to', $to);
        }

        if($yearForMonthly){
            $favorites
                ->andWhere(':year = (CASE WHEN (ur.fromFavoriteStatus = :favorite OR  ur.fromFavoriteStatus = :newFavorite) then year(ur.fromFavoriteCreated) ELSE year(ur.toFavoriteCreated) END)')
                ->setParameter('year', $yearForMonthly);
        }

        $favorites = $favorites->getQuery()->getResult();

        $this->myMergeArrays($favorites, $result, 'Favorite', $groupBy);

        $friends =  $this->getEntityManager()
            ->createQueryBuilder()
            ->select('count(ur.id) as cnt,
                          (CASE WHEN ur.toStatusCreated > ur.fromStatusCreated  then date(ur.toStatusCreated)  ELSE date(ur.fromStatusCreated) END) as created')
            ->from("LBUserBundle:UserRelation", "ur")
            ->where("(ur.fromStatus = :like and ur.toStatus = :like)")
            ->groupBy('created')
            ->setParameter('like', UserRelation::LIKE)
            ;

        if($from){
            $friends
                ->andWhere(':from <= (CASE WHEN ur.toStatusCreated > ur.fromStatusCreated  then date(ur.toStatusCreated)  ELSE date(ur.fromStatusCreated) END)')
                ->setParameter('from', $from);
        }
        if($to){
            $friends
                ->andWhere(':to >= (CASE WHEN ur.toStatusCreated > ur.fromStatusCreated  then date(ur.toStatusCreated)  ELSE date(ur.fromStatusCreated) END)')
                ->setParameter('to', $to);
        }

        if($yearForMonthly){
            $friends
                ->andWhere(':year = (CASE WHEN ur.toStatusCreated > ur.fromStatusCreated  then year(ur.toStatusCreated)  ELSE year(ur.fromStatusCreated) END)')
                ->setParameter('year', $yearForMonthly);
        }

        $friends = $friends->getQuery()->getResult();

        $this->myMergeArrays($friends, $result, 'Friends', $groupBy);

        $messages =  $this->getEntityManager()
            ->createQueryBuilder()
            ->select('count(m.id) as cnt, date(m.created) as created')
            ->from("LBMessageBundle:Message", "m")
            ->groupBy('created')
            ;

        if($from){
            $messages
                ->andWhere(':from <= date(m.created) ')
                ->setParameter('from', $from);
        }
        if($to){
            $messages
                ->andWhere(':to >= date(m.created) ')
                ->setParameter('to', $to);
        }

        if($yearForMonthly){
            $messages
                ->andWhere(':year = year(m.created) ')
                ->setParameter('year', $yearForMonthly);
        }

        $messages = $messages->getQuery()->getResult();

        $this->myMergeArrays($messages, $result, 'Messages', $groupBy);

        ksort($result);

        return $result;
    }

    /**
     * @param $firstArray
     * @param $mergedArray
     * @param $type
     */
    private function myMergeArrays($firstArray, &$mergedArray, $type, $groupBy)
    {
        // check is array
        if(is_array($firstArray) and count($firstArray) > 0){
            foreach($firstArray as $key => $array){

                // check is created null
                 if($array['created'] == null){
                    continue;
                }

                // get key
                $key  = $array['created'];

                // switch for group by
                switch($groupBy){
//                    case MetricController::WEEK:
//                        break;
                    case MetricController::MONTH:
                        $key = substr($key, 5, 2);
                        break;
                    case MetricController::YEAR:
                        $key = substr($key, 0, 4);
                        break;
                }

                if(isset($mergedArray[$key][$type])){
                    $mergedArray[$key][$type] = $mergedArray[$key][$type] + $array['cnt'];
                }
                else{
                    $mergedArray[$key][$type] = $array['cnt'];
                }
            }
        }
    }

    /**
     * @param $currentUser
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     * @param null $start
     * @param null $count
     */
    public function findLikesUsersForMobile($currentUser, $start , $count )
    {
        $query =  $this->getEntityManager()
            ->createQuery("SELECT ur,
                            (CASE WHEN ur.fromUser = :currentUser then ur.isLikeReadTo ELSE ur.isLikeReadFrom END) as HIDDEN status,
                            (CASE WHEN ur.fromUser = :currentUser then ur.toStatusCreated ELSE ur.fromStatusCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           JOIN ur.toUser tu
                           WHERE (ur.toUser = :currentUser AND ur.fromStatus = :status AND ur.toStatus != :status) OR
                           (ur.fromUser = :currentUser AND ur.toStatus = :status AND ur.fromStatus != :status)
                           ORDER BY status ASC, created DESC
                           ")
            ->setParameter('currentUser', $currentUser->getId())
            ->setFirstResult($start)
            ->setMaxResults($count)
            ->setParameter('status', UserRelation::LIKE);

            $paginator = new Paginator($query, $fetchJoinCollection = true);

            // get result
            $result = $paginator->getIterator()->getArrayCopy();

            return $result;
    }

    /**
     * @param $currentUser
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     * @param null $start
     * @param null $count
     */
    public function findFriendsForMobile($currentUser, $start , $count )
    {
        $query =  $this->getEntityManager()
            ->createQuery("SELECT ur,
                            (CASE WHEN ur.fromUser = :currentUser then ur.isLikeReadTo ELSE ur.isLikeReadFrom END) as HIDDEN status,
                            (CASE WHEN ur.fromUser = :currentUser then ur.toStatusCreated ELSE ur.fromStatusCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           JOIN ur.toUser tu
                           WHERE (ur.toUser = :currentUser AND ur.fromStatus = :status AND ur.toStatus = :status) OR
                           (ur.fromUser = :currentUser AND ur.toStatus = :status AND ur.fromStatus = :status)
                           ORDER BY status ASC, created DESC
                           ")
            ->setParameter('currentUser', $currentUser->getId())
            ->setFirstResult($start)
            ->setMaxResults($count)
            ->setParameter('status', UserRelation::LIKE);

        $paginator = new Paginator($query, $fetchJoinCollection = true);

        // get result
        $result = $paginator->getIterator()->getArrayCopy();

        return $result;
    }


    /**
     * @param $currentUser
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findLikeByMeUsers($currentUser)
    {
        return $this->getEntityManager()
            ->createQuery("SELECT ur, fu, tu, tui, fui,
                            (CASE WHEN ur.fromUser = :currentUser then ur.fromStatusCreated ELSE ur.toStatusCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           LEFT JOIN fu.profileImage fui
                           JOIN ur.toUser tu
                           LEFT JOIN tu.profileImage tui
                           WHERE (tu.id = :currentUser AND ur.toStatus = :status AND ur.fromStatus != :status) OR (fu.id = :currentUser AND ur.fromStatus = :status AND ur.toStatus != :status)
                           ORDER BY created DESC
                           ")
            ->setHint(Query::HINT_FORCE_PARTIAL_LOAD, true)
            ->setParameter('currentUser', $currentUser->getId())
            ->setParameter('status', UserRelation::LIKE)
            ->getResult();
    }


    /**
     * @param $currentUser
     * @return mixed
     * @param $start
     * @param $count
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findLikeByMeUsersForMobile($currentUser, $start, $count)
    {
        $query =  $this->getEntityManager()
            ->createQuery("SELECT ur,
                            (CASE WHEN ur.fromUser = :currentUser then ur.fromStatusCreated ELSE ur.toStatusCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           JOIN ur.toUser tu
                           WHERE (ur.toUser = :currentUser AND ur.toStatus = :status AND ur.fromStatus != :status AND ur.fromStatus != :block) OR (ur.fromUser = :currentUser AND ur.fromStatus = :status AND ur.toStatus != :status AND ur.toStatus != :block)
                           ORDER BY created DESC
                           ")
            ->setParameter('currentUser', $currentUser)
            ->setParameter('status', UserRelation::LIKE)
            ->setParameter('block', UserRelation::BLOCK)
            ->setFirstResult($start)
            ->setMaxResults($count)
        ;

        $paginator = new Paginator($query, $fetchJoinCollection = true);

        // get result
        $result = $paginator->getIterator()->getArrayCopy();

        return $result;
    }


    /**
     * @param $currentUser
     * @param $like
     * @param null $otherUsers
     * @param null $userRelations
     */
    public function updateLikesUsers($currentUser, $otherUsers = null, $userRelations = null, $like = true)
    {
        // update first part
        $queryFrom = $this->getEntityManager()
            ->createQueryBuilder()
            ->update('LBUserBundle:UserRelation',  'ur')
            ->set('ur.isLikeReadTo', TRUE)
            ->where("ur.fromUser = :user")
            ->setParameter('user', $currentUser)

        ;

        // check like
        if($like){
            $queryFrom
                ->andWhere("ur.fromStatus != :status")
                ->setParameter('status', UserRelation::LIKE)
            ;
        }

        if(count($otherUsers) > 0){
            $queryFrom
                ->andWhere('ur.toUser IN (:otherUsers)')
                ->setParameter('otherUsers', $otherUsers);
        }
        if(count($userRelations) > 0){
            $queryFrom
                ->andWhere('ur IN (:usRelations)')
                ->setParameter('usRelations', $userRelations);
        }
        $queryFrom->getQuery()->execute();


        // update other part
        $queryTo = $this->getEntityManager()
            ->createQueryBuilder()
            ->update('LBUserBundle:UserRelation',  'ur')
            ->set('ur.isLikeReadFrom', TRUE)
            ->where("ur.toUser = :user")
            ->setParameter('user', $currentUser)
        ;

        // check like
        if($like){
            $queryFrom
                ->andWhere("ur.toStatus != :status")
                ->setParameter('status', UserRelation::LIKE)
            ;
        }

        if(count($otherUsers)){
            $queryTo
                ->andWhere('ur.fromUser IN (:otherUsers)')
                ->setParameter('otherUsers', $otherUsers);
        }
        if(count($userRelations) > 0){
            $queryTo
                ->andWhere('ur IN (:usRelations)')
                ->setParameter('usRelations', $userRelations);
        }
        $queryTo->getQuery()->execute();
    }

    /**
     * This function used to determine if two users are friends
     *
     * @param $user1Id
     * @param $user2Id
     * @return bool
     */
    public function areFriends($user1Id, $user2Id)
    {
        $userRelation = $this->getEntityManager()
            ->createQuery("SELECT ur
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           JOIN ur.toUser tu
                           WHERE ((fu.id= :user1Id AND tu.id = :user2Id) OR (fu.id= :user2Id AND tu.id = :user1Id))
                           AND ur.fromStatus = :likeStatus AND ur.toStatus = :likeStatus")
            ->setParameter('user1Id', $user1Id)
            ->setParameter('user2Id', $user2Id)
            ->setParameter('doubleLikeCode', UserRelation::LIKE)
            ->getResult();

        if (count($userRelation)){
            return true;
        }

        return false;
    }

    /**
     * @param $userId
     * @return array
     */
    public function findUnreadLikesCount($userId)
    {
        return $this->getEntityManager()
            ->createQuery("SELECT COUNT(ur)
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           JOIN ur.toUser tu
                           WHERE ((tu.id = :currentUser AND ur.fromStatus = :status AND ur.isLikeReadFrom = false) OR (fu.id = :currentUser AND ur.toStatus = :status AND ur.isLikeReadTo = false))")
            ->setParameter('currentUser', $userId)
            ->setParameter('status', UserRelation::LIKE)
            ->getSingleScalarResult();
    }

    /**
     * @param $user
     * @param array $blocks
     * @return array
     */
    public function findAllUnread($user, $blocks = [-1])
    {
        $result =  array(
            'likeCount' => 0,
            'visitorCount' => 0,
            'messageCount' => 0,
            'favoriteCount' => 0,
            'friendsCount' => 0
        );

        $query = $this->getEntityManager()
            ->createQuery("
            SELECT
            SUM(CASE WHEN (ur.toUser = :currentUser AND ur.fromFavoriteStatus = :favoriteStatus)  OR (ur.fromUser = :currentUser AND ur.toFavoriteStatus = :favoriteStatus)  THEN 1 ELSE 0 END) AS favoriteCount,
            SUM(CASE WHEN (ur.toUser = :currentUser AND ur.fromVisitorStatus = :visitStatus)  OR (ur.fromUser = :currentUser AND ur.toVisitorStatus = :visitStatus)  THEN 1 ELSE 0 END) AS visitorCount,
            SUM(CASE WHEN (ur.toUser = :currentUser AND ur.fromStatus = :likeStatus AND ur.toStatus != :likeStatus AND ur.isLikeReadFrom = false) OR (ur.fromUser = :currentUser AND ur.toStatus = :likeStatus AND ur.fromStatus != :likeStatus AND ur.isLikeReadTo = false)  THEN 1 ELSE 0 END) AS likeCount,
            SUM(CASE WHEN ((ur.toUser = :currentUser AND ur.isLikeReadFrom = false) OR (ur.fromUser = :currentUser AND ur.isLikeReadTo = false)) AND ur.fromStatus = :likeStatus AND ur.toStatus = :likeStatus  THEN 1 ELSE 0 END) AS friendsCount
            FROM LBUserBundle:UserRelation ur
            JOIN ur.fromUser fu
            JOIN ur.toUser tu
            WHERE (ur.fromUser = :currentUser AND ur.toStatus != :block ) or( ur.toUser = :currentUser AND ur.fromStatus != :block)

            ")
            ->setParameter('currentUser', $user->getId())
            ->setParameter('block', UserRelation::BLOCK)
            ->setParameter('favoriteStatus', UserRelation::NEW_FAVORITE)
            ->setParameter('visitStatus', UserRelation::NEW_VISITOR)
            ->setParameter('likeStatus', UserRelation::LIKE)

            ->getSingleResult();




        $messageQuery =  $this->getEntityManager()
            ->createQuery("SELECT COUNT(m.id) as messageCount
                           FROM LBMessageBundle:Message m
                           JOIN m.fromUser fu
                           WHERE fu not in (:ids) AND m.toUser  = :currentUser AND m.isRead  = false AND m.isDeleted != 1")
            ->setParameter('currentUser', $user->getId())
            ->setParameter('ids', $blocks)
            ->getSingleResult()
        ;

        if($query){

            $result['likeCount'] = (int)$query['likeCount'];
            $result['visitorCount'] = (int)$query['visitorCount'];
            $result['favoriteCount'] = (int)$query['favoriteCount'];
            $result['friendsCount'] = (int)$query['friendsCount'];

        }


        if($messageQuery){
            $result['messageCount'] = (int)$messageQuery['messageCount'];
        }

        return $result;


//        $stmt = $this->getEntityManager()
//            ->getConnection()
//            ->prepare('
//                        SELECT * FROM
//                        (
//                          SELECT COUNT(*) as likeCount FROM user_relation
//                          WHERE (to_user_id = :currentUser AND from_status = :likeStatus AND to_status != :likeStatus AND is_like_read_from = false) OR (from_user_id = :currentUser AND to_status = :likeStatus AND from_status != :likeStatus AND  is_like_read_to = false)
//                        ) as likeCount,
//
//                        (
//                          SELECT COUNT(*) as favoriteCount FROM user_relation
//                          WHERE (to_user_id = :currentUser AND from_favorite_status = :favoriteStatus) OR (from_user_id = :currentUser AND to_favorite_status = :favoriteStatus)
//                        ) as favoriteCount,
//
//                        (
//                          SELECT COUNT(*) as visitorCount FROM user_relation
//                          WHERE (to_user_id = :currentUser AND from_visitor_status = :visitStatus) OR (from_user_id = :currentUser AND to_visitor_status = :visitStatus)
//                        ) as visitorCount,
//
//                        (
//                          SELECT COUNT(*) as friendsCount FROM user_relation
//                          WHERE ((to_user_id = :currentUser AND is_like_read_from = false) OR (from_user_id = :currentUser AND is_like_read_to = false)) AND to_status = :likeStatus AND from_status = :likeStatus
//                        ) as friendsCount,
//
//                        (
//                          SELECT COUNT(*) as messageCount FROM message
//                          WHERE from_user_id is not null AND  to_user_id = :currentUser AND is_read = false AND is_deleted != 1
//                        ) as messageCount
//
//                        ');
//        $stmt->bindValue('currentUser', $user->getId());
//        $stmt->bindValue('likeStatus', UserRelation::LIKE);
//        $stmt->bindValue('visitStatus', UserRelation::NEW_VISITOR);
//        $stmt->bindValue('favoriteStatus', UserRelation::NEW_FAVORITE);
//        $stmt->execute();
//        return  $stmt->fetchAll();

    }
    /**
     * This function is used to find visitor users by current id
     *
     * @param userid
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findVisitorUsers($userId)
    {
        return $this->getEntityManager()
            ->createQuery("SELECT ur, tu, fu, tui, fui,
                            (CASE WHEN ur.fromUser = :userId then ur.toVisitorStatus ELSE ur.fromVisitorStatus END) as HIDDEN status,
                            (CASE WHEN ur.fromUser = :userId then ur.toVisitCreated ELSE ur.fromVisitCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.toUser tu
                           LEFT JOIN tu.profileImage tui
                           JOIN ur.fromUser fu
                           LEFT JOIN fu.profileImage fui
                           WHERE (tu.id = :userId AND ur.fromVisitorStatus IN (:visitStatuses)) OR
                           (fu.id = :userId AND ur.toVisitorStatus IN (:visitStatuses))
                           ORDER BY status ASC, created DESC")
            ->setParameter('userId', $userId)
            ->setParameter('visitStatuses', array(UserRelation::VISITOR, UserRelation::NEW_VISITOR))
            ->setHint(Query::HINT_FORCE_PARTIAL_LOAD, true)
            ->getResult();
    }

    /**
     * This function is used to find visitor users by current id
     *
     * @param userid
     * @return mixed
     * @param $start
     * @param $count
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findVisitorUsersForMobile($userId, $start, $count)
    {
        $query =  $this->getEntityManager()
            ->createQuery("SELECT ur,
                            (CASE WHEN ur.fromUser = :userId then ur.toVisitorStatus ELSE ur.fromVisitorStatus END) as HIDDEN status,
                            (CASE WHEN ur.fromUser = :userId then ur.toVisitCreated ELSE ur.fromVisitCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           JOIN ur.toUser tu
                           WHERE (ur.toUser = :userId AND ur.fromStatus != :block AND ur.fromVisitorStatus IN (:visitStatuses)) OR
                           (ur.fromUser = :userId AND ur.toStatus != :block AND ur.toVisitorStatus IN (:visitStatuses))
                           ORDER BY status ASC, created DESC")
            ->setParameter('userId', $userId)
            ->setParameter('visitStatuses', array(UserRelation::VISITOR, UserRelation::NEW_VISITOR))
            ->setParameter('block', UserRelation::BLOCK)
            ->setFirstResult($start)
            ->setMaxResults($count)
            ;

        $paginator = new Paginator($query, $fetchJoinCollection = true);

        // get result
        $result = $paginator->getIterator()->getArrayCopy();

        return $result;
    }

    /**
     * This function is used to update visitor users new status
     *
     * @param userId
     * @return mixed
     * @param null $otherUsers
     * @param null $userRelations
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function updateVisitorUsers($user, $otherUsers = null, $userRelations = null)
    {
        // update first part
        $queryFrom = $this->getEntityManager()
            ->createQueryBuilder()
            ->update('LBUserBundle:UserRelation',  'ur')
            ->set('ur.toVisitorStatus', ':visitStatus')
            ->where("ur.fromUser = :user AND ur.toVisitorStatus = :newVisitStatus")
            ->setParameter('user', $user)
            ->setParameter('visitStatus', UserRelation::VISITOR)
            ->setParameter('newVisitStatus', UserRelation::NEW_VISITOR)
        ;
        if(count($otherUsers) > 0){
            $queryFrom
                ->andWhere('ur.toUser IN (:otherUsers)')
                ->setParameter('otherUsers', $otherUsers);
        }
        if(count($userRelations) > 0){
            $queryFrom
                ->andWhere('ur IN (:usRelations)')
                ->setParameter('usRelations', $userRelations);
        }
        $queryFrom->getQuery()->execute();

        // update other part
        $queryTo = $this->getEntityManager()
            ->createQueryBuilder()
            ->update('LBUserBundle:UserRelation',  'ur')
            ->set('ur.fromVisitorStatus', ':visitStatus')
            ->where("ur.toUser = :user AND ur.fromVisitorStatus = :newVisitStatus")
            ->setParameter('user', $user)
            ->setParameter('visitStatus', UserRelation::VISITOR)
            ->setParameter('newVisitStatus', UserRelation::NEW_VISITOR)
        ;
        if(count($otherUsers)){
            $queryTo
                ->andWhere('ur.fromUser IN (:otherUsers)')
                ->setParameter('otherUsers', $otherUsers);
        }
        if(count($userRelations) > 0){
            $queryTo
                ->andWhere('ur IN (:usRelations)')
                ->setParameter('usRelations', $userRelations);
        }
        $queryTo->getQuery()->execute();

    }

    /**
     * This function is used to get new visitors users count
     *
     * @param $userId
     * @return array
     */
    public function findUnreadVisitorsCount($userId)
    {
        return $this->getEntityManager()
            ->createQuery("SELECT COUNT(ur)
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.toUser tu
                           JOIN ur.fromUser fu
                           WHERE (tu.id = :userId AND ur.fromVisitorStatus = :status)
                           OR (fu.id = :userId AND ur.toVisitorStatus = :status)
                           ")
            ->setParameter('userId', $userId)
            ->setParameter('status', UserRelation::NEW_VISITOR)
            ->getSingleScalarResult();
    }

    /**
     * This function is used to find favorite users by current id
     *
     * @param userId
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findFavoriteUsers($userId)
    {
        return $this->getEntityManager()
            ->createQuery("SELECT ur, tu, fu, tui, fui,
                           (CASE WHEN ur.fromUser = :userId then ur.toFavoriteStatus ELSE ur.fromFavoriteStatus END) as HIDDEN status,
                           (CASE WHEN ur.fromUser = :userId then ur.toFavoriteCreated ELSE ur.fromFavoriteCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.toUser tu
                           LEFT JOIN tu.profileImage tui
                           JOIN ur.fromUser fu
                           LEFT JOIN fu.profileImage fui
                           WHERE (tu.id = :userId AND ur.fromFavoriteStatus IN (:favoriteStatuses)) OR
                           (fu.id = :userId AND ur.toFavoriteStatus IN (:favoriteStatuses))
                           ORDER BY status DESC, created DESC")
            ->setParameter('userId', $userId)
            ->setParameter('favoriteStatuses', array(UserRelation::FAVORITE, UserRelation::NEW_FAVORITE))
            ->getResult();
    }

    /**
     * This function is used to find favorite users by current id
     *
     * @param userId
     * @return mixed
     * @param $start
     * @param $count
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findFavoriteUsersForMobile($userId, $start, $count)
    {
        $query =  $this->getEntityManager()
            ->createQuery("SELECT ur,
                           (CASE WHEN ur.fromUser = :userId then ur.toFavoriteStatus ELSE ur.fromFavoriteStatus END) as HIDDEN status,
                           (CASE WHEN ur.fromUser = :userId then ur.toFavoriteCreated ELSE ur.fromFavoriteCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           JOIN ur.toUser tu
                           WHERE (ur.toUser = :userId  AND ur.fromStatus != :block AND  ur.fromFavoriteStatus IN (:favoriteStatuses)) OR
                           (ur.fromUser = :userId  AND ur.toStatus != :block AND ur.toFavoriteStatus IN (:favoriteStatuses))
                           ORDER BY status DESC, created DESC")
            ->setParameter('userId', $userId)
            ->setParameter('favoriteStatuses', array(UserRelation::FAVORITE, UserRelation::NEW_FAVORITE))
            ->setParameter(':block', UserRelation::BLOCK)
            ->setFirstResult($start)
            ->setMaxResults($count);

        $paginator = new Paginator($query, $fetchJoinCollection = true);

        // get result
        $result = $paginator->getIterator()->getArrayCopy();

        return $result;
    }


    /**
     * This function is used to find favorite users by current id
     *
     * @param userId
     * @return mixed
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findFavoriteByMeUsers($userId)
    {
        return $this->getEntityManager()
            ->createQuery("SELECT ur, tu, fu, tui, fui,
                           (CASE WHEN ur.fromUser = :userId then ur.fromFavoriteCreated ELSE ur.toFavoriteCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.toUser tu
                           LEFT JOIN tu.profileImage tui
                           JOIN ur.fromUser fu
                           LEFT JOIN fu.profileImage fui
                           WHERE (tu.id = :userId AND ur.toFavoriteStatus IN (:favoriteStatuses)) OR
                           (fu.id = :userId AND ur.fromFavoriteStatus IN (:favoriteStatuses))
                           ORDER BY created DESC ")
            ->setParameter('userId', $userId)
            ->setParameter('favoriteStatuses', array(UserRelation::FAVORITE, UserRelation::NEW_FAVORITE))
            ->getResult();
    }

    /**
     * This function is used to find favorite users by current id
     *
     * @param userId
     * @return mixed
     * @param $start
     * @param $count
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function findFavoriteByMeUsersForMobile($userId, $start, $count)
    {
        $query =  $this->getEntityManager()
            ->createQuery("SELECT ur,
                           (CASE WHEN ur.fromUser = :userId then ur.fromFavoriteCreated ELSE ur.toFavoriteCreated END) as HIDDEN created
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.fromUser fu
                           JOIN ur.toUser tu
                           WHERE (ur.toUser = :userId AND ur.fromStatus != :block AND ur.toFavoriteStatus IN (:favoriteStatuses)) OR
                           (ur.fromUser = :userId AND ur.toStatus != :block AND ur.fromFavoriteStatus IN (:favoriteStatuses))
                           ORDER BY created DESC ")
            ->setParameter('userId', $userId)
            ->setParameter('favoriteStatuses', array(UserRelation::FAVORITE, UserRelation::NEW_FAVORITE))
            ->setParameter('block', UserRelation::BLOCK)
            ->setFirstResult($start)
            ->setMaxResults($count);

        $paginator = new Paginator($query, $fetchJoinCollection = true);

        // get result
        $result = $paginator->getIterator()->getArrayCopy();

        return $result;
    }

    /**
     * This function is used to update favorite users new status
     *
     * @param $user
     * @return mixed
     * @param null $otherUsers
     * @param null $userRelations
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function updateFavoriteUsers($user, $otherUsers = null, $userRelations = null)
    {
        // update first part
        $queryFrom = $this->getEntityManager()
            ->createQueryBuilder()
            ->update('LBUserBundle:UserRelation',  'ur')
            ->set('ur.toFavoriteStatus', ':favoriteStatus')
            ->where("ur.fromUser = :user AND ur.toFavoriteStatus = :newFavoriteStatus")
            ->setParameter('user', $user)
            ->setParameter('favoriteStatus', UserRelation::FAVORITE)
            ->setParameter('newFavoriteStatus', UserRelation::NEW_FAVORITE)
        ;
        if(count($otherUsers) > 0){
            $queryFrom
                ->andWhere('ur.toUser IN (:otherUsers)')
                ->setParameter('otherUsers', $otherUsers);
        }
        if(count($userRelations) > 0){
            $queryFrom
                ->andWhere('ur IN (:usRelations)')
                ->setParameter('usRelations', $userRelations);
        }
        $queryFrom->getQuery()->execute();

        // update other part
        $queryTo = $this->getEntityManager()
            ->createQueryBuilder()
            ->update('LBUserBundle:UserRelation',  'ur')
            ->set('ur.fromFavoriteStatus', ':favoriteStatus')
            ->where("ur.toUser = :user AND ur.fromFavoriteStatus = :newFavoriteStatus")
            ->setParameter('user', $user)
            ->setParameter('favoriteStatus', UserRelation::FAVORITE)
            ->setParameter('newFavoriteStatus', UserRelation::NEW_FAVORITE)
        ;
        if(count($otherUsers)){
            $queryTo
                ->andWhere('ur.fromUser IN (:otherUsers)')
                ->setParameter('otherUsers', $otherUsers);
        }
        if(count($userRelations) > 0){
            $queryTo
                ->andWhere('ur IN (:usRelations)')
                ->setParameter('usRelations', $userRelations);
        }
        $queryTo->getQuery()->execute();

    }

    /**
     * This function is used to get new favorite users count
     *
     * @param $userId
     * @return array
     */
    public function findUnreadFavoriteCount($userId)
    {
        return $this->getEntityManager()
            ->createQuery("SELECT COUNT(ur)
                           FROM LBUserBundle:UserRelation ur
                           JOIN ur.toUser tu
                           JOIN ur.fromUser fu
                           WHERE (tu.id = :userId AND ur.fromFavoriteStatus = :status)
                           OR (fu.id = :userId AND ur.toFavoriteStatus = :status)
                           ")
            ->setParameter('userId', $userId)
            ->setParameter('status', UserRelation::NEW_FAVORITE)
            ->getSingleScalarResult();
    }
}
